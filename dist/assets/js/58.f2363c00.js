(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{741:function(t,e,a){"use strict";a.r(e);var n=a(3),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"什么是模板引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是模板引擎"}},[t._v("#")]),t._v(" 什么是模板引擎")]),t._v(" "),a("ul",[a("li",[t._v("将数据变成视图最优雅的解决方法。")]),t._v(" "),a("li",[t._v("v-for：实际上也是一直模板引擎")]),t._v(" "),a("li",[t._v("历史方法：\n"),a("ol",[a("li",[t._v("纯DOM法：通过createElement标签，在追加节点（上树）。")]),t._v(" "),a("li",[t._v("数组join法：var str=['A','B','C','D'].join('')  输出结果：ABCD   （可以实现换行）")]),t._v(" "),a("li",[t._v("ES6的模板语法：反引号、变量")]),t._v(" "),a("li",[t._v("模板引擎:mustache:{{}}")])])])]),t._v(" "),a("h2",{attrs:{id:"模板引擎的基本语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板引擎的基本语法"}},[t._v("#")]),t._v(" 模板引擎的基本语法")]),t._v(" "),a("ol",[a("li",[t._v("基本对象：{{}}")]),t._v(" "),a("li",[t._v("循环对象：")])]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("    开始循环：'{{#数组名}}'\n    简单数组'{{.}} '   数组对象'{{数组对象的键名}}'\n    结束循环：'{{/数组名}}'\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("使用Mustache.render(temp,data);第一参数：模板；第二个参数：数据 返回结果：dom结构的字符串")])]),t._v(" "),a("h2",{attrs:{id:"mustache的底层核心机理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mustache的底层核心机理"}},[t._v("#")]),t._v(" Mustache的底层核心机理")]),t._v(" "),a("p",[t._v("猜测：")]),t._v(" "),a("ul",[a("li",[t._v("简单情况：使用正则表达式+replace()；")]),t._v(" "),a("li",[t._v("复杂情况：不仅仅是正则")])]),t._v(" "),a("p",[t._v("实际机理：")]),t._v(" "),a("ul",[a("li",[t._v("1）先将模板字符串编译成tokens：\ntokens：是一个JS的嵌套数组，就是模板字符串用JS表示。是抽象语法树（AST）、虚拟节点等的开山鼻祖。\n注意：当模板字符串中有循环存在，就会编译为嵌套更深的tokens")]),t._v(" "),a("li",[t._v("2）将tokens和数据进行结合，解析成dom字符串")])]),t._v(" "),a("h2",{attrs:{id:"实现模板引擎核心功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现模板引擎核心功能"}},[t._v("#")]),t._v(" 实现模板引擎核心功能")]),t._v(" "),a("ul",[a("li",[t._v("定义一个扫描Scanner类，用于扫描传进来的模板字符串")])]),t._v(" "),a("p",[t._v("（1）定义一个当扫描指针遇到“{{”等指定符号就跳过的scan（）方法")]),t._v(" "),a("p",[t._v("（2）定义一个当扫描指针直到遇见指定内容结束，并返回扫描过的内容的scanUntil（）方法")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("定义一个Totokens（）函数：用于将模板字符串变为tokens数组，将扫描的内容push（）进tokens数组里")]),t._v(" "),a("ul",[a("li",[t._v("1）简单情况（没有循环）："),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('定义一个tokens，\n- 当扫描器扫描到{{}}里面的内容，\n就将其以["name":扫描的内容]的形式，作为一个token添加进tokens数组中；\n- 当扫描器扫描到{{}}之外的内容，将其以["text":扫描过的内容]，作为一个token添加进tokens数组中\n')])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])])]),t._v(" "),a("li",[t._v("2）循环情况（带#和/）："),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("当扫描器扫描到{{#数组名}}中的#时开始，到{{/数组名}}中的/结束，\n则说明将要循环遍历出里对应的token，作为一个子tokens，添加到toekens中。\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])])])]),t._v(" "),a("p",[t._v("附：定义一个nestTokens函数，用于处理循环情况，折叠tokens：将#号和/里的token整合。")])]),t._v(" "),a("li",[a("p",[t._v("3）定义一个renderTemp（）函数：用于将tokens数组和data数据结合，变成dom字符串")]),t._v(" "),a("ul",[a("li",[t._v("(1)当每个token[0]是text类型时，就原样拼接该token[1]中的dom字符串")]),t._v(" "),a("li",[t._v("(2)当每个token[0]是name类型时，则需要和data相关数据进行替换，最后将替换后的dom字符串拼接")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("注意：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("- 1、当模板中要替换的数据为单层结构时：可直接根据data中数据的键名，取得相应数据\n\n- 2、当模板中要替换的数据为多层结构时：如dataObj={a:{b:{c:100}}}，我们需要将'a.b.c'的结果输出为：100。\n\n- 所以定义一个lookup()函数,用于解决上述两个问题，实现可以在data对象中，寻找用续点符号的keyName属性\n")])])])]),a("ul",[a("li",[t._v("(3)当每个token[0]是#类型时，则需要根据data中的数组，递归实现实现将tokens和data数据结合，最后将替换好的dom字符串拼接。\n定义一个parseArray()函数，用于将处理数组，结合renderTemp实现递归\n- 第一个参数：token['#',数组名，tokens]，不是tokens\n- 这个函数递归调用renderTemp()的次数由data数组的长度决定")])])]),t._v(" "),a("li",[a("p",[t._v("4）提供全局对象Template中一个render()方法，需要传递两个参数：一个为模板字符串，一个为对应数据data")])])]),t._v(" "),a("h2",{attrs:{id:"相关函数的具体实现要点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关函数的具体实现要点"}},[t._v("#")]),t._v(" 相关函数的具体实现要点")]),t._v(" "),a("h6",{attrs:{id:"_1-scan-tag-路过指定内容-如-跳过"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-scan-tag-路过指定内容-如-跳过"}},[t._v("#")]),t._v(" 1）scan（tag）：路过指定内容，如：跳过}")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("判断this.tail.indexOf(tag) == 0是否遇到指定内容，遇到将指针向后移动指定内容的长度，改变剩余模板字符串\n")])])]),a("h6",{attrs:{id:"_2-scanuntil-stoptag-让指针进行扫描-直到遇见指定内容结束-并返回扫描过的文字-stoptag-停止标志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-scanuntil-stoptag-让指针进行扫描-直到遇见指定内容结束-并返回扫描过的文字-stoptag-停止标志"}},[t._v("#")]),t._v(" 2）scanUntil（stopTag）：让指针进行扫描，直到遇见指定内容结束，并返回扫描过的文字 stopTag:停止标志")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("循环执行扫描，改变指针的位置，当遇到指定内容时，返回路过的字符，并记录当前指针位置，直到扫描完模板字符串停止\n")])])]),a("h6",{attrs:{id:"_3-totokens-tempstr-将模板字符串-tempstr-变为tokens数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-totokens-tempstr-将模板字符串-tempstr-变为tokens数组"}},[t._v("#")]),t._v(" 3）Totokens（tempStr）：将模板字符串（tempStr）变为tokens数组")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("创建一个扫描类，将扫描过的返回的模板字符串，根据返回的模板进行分类；\n    定义一个toekns数组，将不同分类都pish()进去\n（1）nestTokens（tokens）：折叠tokens，将#号和/里的token整合\n    - 定义一个栈结构（先进后出）：存放小tokens，\n    - 定义一个收集器collector：开始指向nestTokens这个结果数组  var collector = nestTokens\n    - 收集器的指向会变化，当遇见#，收集器指向这个token的下标为2的新数组\n    当遇到#时：\n            // 收集器里放入token\n            collector.push(token);\n            // 入栈\n            sections.push(token);\n            //收集器换为下标为2的数组['#','name',[]]\n            collector = token[2] = [];\n    当遇到\"/\"时：\n            // 出栈 pop()会返回弹出的项\n            sections.pop();\n            // 改变栈结构栈顶,那一项下标为2的数组\n            collector = sections.length > 0 ? sections[sections.length - 1][2] : nestTokens;\n    当其他情况：\n            //将token放入收集器里\n             collector.push(token);\n    最后将折叠好的nestTokens返回。\n")])])]),a("h6",{attrs:{id:"_4-rendertemp-tokens-data-用于将tokens数组和data数据结合-变成dom字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-rendertemp-tokens-data-用于将tokens数组和data数据结合-变成dom字符串"}},[t._v("#")]),t._v(" 4）renderTemp（tokens,data）：用于将tokens数组和data数据结合，变成dom字符串")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("将Totokens(tokens)处理好返回的tokens和data传入renderTemp()函数中，根据tokens中每个token[0]中的类型进行数据匹配。\n    -当token[0]是text类型：\n        只需要将每个token[1]进行追加\n    -当token[0]是name类型：\n        （1）lookup(dataObj, keyName)：实现可以在data对象中，寻找用续点符号的keyName属性（主要解决多层的数据结构）\n        先判断keyName是否含有点符号(如'a.b')keyName.indexOf(\".\") != -1 && keyName!==\".\",\n        如果有，则拆开为数组keyName.split('.');再循环一层一层找下去对应数据。\n        如果没有，则直接返回dataObj[keyName]\n    -当token[0]是#类型：\n        （1）parseArray(token, data)：用于将处理数组，结合renderTemp实现递归\n            * 处理数组，结合renderTemp实现递归\n            * 第一个参数：token['#',数组名，tokens]，不是tokens\n            * 这个函数递归调用renderTemp()的次数由data数组的长度决定\n            // 得到整体数据data中的这个数组要使用的部分\n            var v = lookup(data, token[1]);\n            // 当v是一个数组时\n            v.forEach(element => {\n                // 注意：当数据为：a.b的形式时,这里需要补一个“.”属性,\n                resultStr += renderTemp(token[2], {\n                    ...element,\n                    '.': element\n                })\n            });\n            返回resultStr\n")])])]),a("h6",{attrs:{id:"_5-render-tempstr-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-render-tempstr-data"}},[t._v("#")]),t._v(" 5）render(tempStr, data)：")]),t._v(" "),a("ol",[a("li",[t._v("调用Totokens函数，将模板字符串变为tokens数组")]),t._v(" "),a("li",[t._v("调用renderTemp函数，将tokens数组变成dom字符串，")]),t._v(" "),a("li",[t._v("返回dom字符串")])])])}),[],!1,null,null,null);e.default=s.exports}}]);