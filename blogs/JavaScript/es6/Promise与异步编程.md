---
title: Promise与异步编程
date: 2022-04-10
tags:
  - JavaScript
  - Promise
categories:
  - es6
---

## 异步编程的背景知识

JavaScript 引擎是基于**单线程**（Single-threaded）事件循环的概念构建的，同一时刻只允许一个代码块在执行，与之相反的是像 Java 和 C++ 一样的语言，他们允许多个不同的代码块同时执行。对于基于线程的软件而言，当多个代码块同时访问并改变状态时，程序很难维护并保证状态不会出错。<br>
JavaScript 引擎同一时刻只能执行一个代码块，所以需要跟踪即将运行的代码，那些代码被放在一个**任务队列**（job queue）中，每当一段代码准备执行时，都会被添加到任务队列。每当 JavaScript 引擎中的一段代码结束执行，**事件循环**（event loop）会执行队列中的下一个任务，他是 JavaScript 引擎中的一段程序，负责监控代码执行并管理任务队列。请记住，队列中的任务会从第一个一直执行到最后一个。

### 事件模型

用户点击按钮或按下键盘上的按键会触发类似 onclick 这样的事件，它会向任务队列添加一个新任务来响应用户的操作，这是 JavaScript 中最基础的异步编程形式，直到事件触发才执行事件处理程序，且执行时上下文与定义时的相同。如：

```js
let button = documnet.getElementById('my-btn')
button.onclick = function(event){
  console.log('clicked)
}
```

事件模型适用于处理简单的交互，然而将多个独立的异步调用连接在一起会使程序更加复杂。尽管事件模型适用于响应用户交互和完成类似的低频功能，但对于更复杂的需求来说却不是很灵活。

### 回调模式

Node.js 通过普及回调函数来改进异步编程模型，回调模式与事件模型类似，异步代码都会在未来的某个时间点执行，二者的区别是回调模式中被调用的函数是作为参数传入的。例如

```js
readFile('example.txt', function(err, content) {
  if (err) {
    throw err
  }
  console.log(content)
})
console.log('Hi')
```

调用 `readFile()` 函数后，`console.log('Hi')` 会立即执行，当 `readFile()` 结束执行时，会向任务队列的末尾添加一个新任务，该任务包含回调函数及相应的参数，当队列前面所有任务完成后才执行该任务。<br>

回调模式比事件模型更灵活，相比之下，通过回调模式链接多个调用更容易，嵌套函数即可。但是嵌套太多会陷入回调地狱，创建出一堆难以理解和调试的代码。<br>

如果你想实现更复杂的操作，回调函数的局限性同样也会显现出来。例如，并行执行两个异步操作，当两个操作都结束时通知你；或者同时进行两个异步操作，只取优先完成的操作结果。在这些情况下，**Promise** 就能很好的改进这些情况。

## Promise 的基础知识
